{% extends "base.html" %}
{% block content %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/memory_test.css') }}">

<div class="container text-center mt-5">
    <h2>Round {{ round_num }}</h2>
    <h2>Memorize these shapes:</h2>
    <div id="shapes-frame" style="display: none">
        {% for shape in shapes %}
            <div class="shape {{ shape }}" 
                style="background-color: {{ shape_colours[loop.index0] }};
                top: {{ shape_positions[loop.index0].top }}px;
                left: {{ shape_positions[loop.index0].left }}px;">
            </div>
        {% endfor %}
    </div>
</div>

<script>
    // Handle leaving via back button
    // Replace current history entry with a custom state object, {page:1}
    // so the page exists in the stack
    history.replaceState({page:1}, null, location.href);
    // Push a dummy state {page:2} on top so the back button triggers popstate
    history.pushState({page:2}, null, location.href);

    window.addEventListener('popstate', function (event) {
        const goBack = confirm("Warning: your progress will be lost if you go back. Do you wish to continue?");
        if (goBack) {
            // Redirect to main assessments page
            window.location.href = "{{ url_for('main.assessments') }}";
        } else {
            // User cancelled: push dummy state again to block back navigation
            history.pushState({page:2}, null, location.href);
        }
    })

    function calculateAverageTimingDelay(watchTimingCalibration) {
        const t1 = watchTimingCalibration.timing1;
        const t4 = watchTimingCalibration.timing4;

        const t2 = watchTimingCalibration.timing2 / 1e6;
        const t3 = watchTimingCalibration.timing3 / 1e6;

        return Math.round(((t2 - t1) + (t4 - t3)) / 2);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function timingHandshake() {

        var delays = Array(10)
        for (var i = 0; i < 10; i++) {
            var start = performance.now();
            var watchTimingCalibration = await fetch(
                "/assessments/memory_test/time/sync", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        join_code: "{{ join_code }}",
                        device: "browser"
                    })
                }
            )
            var end = performance.now();
            var watchTimingCalibration = await watchTimingCalibration.json();
            watchTimingCalibration.timing1 = start;
            watchTimingCalibration.timing4 = end;
            console.log(watchTimingCalibration)
            delays[i] = calculateAverageTimingDelay(watchTimingCalibration);
            console.log(delays[i])
        }

        var avgDelay = delays.reduce((a, b) => a + b) / delays.length
        var handshakes = Array(5)

        for (var i = 0; i < 5; i++) {
            var handshakeTiming = await fetch(
                "/assessments/memory_test/time/request_future", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        join_code: "{{ join_code }}",
                        delay: avgDelay
                    })
                }
            )
            while (handshakeTiming.status == 206) {
                await sleep(1000);
                handshakeTiming = await fetch(
                    "/assessments/memory_test/time/request_future", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            join_code: "{{ join_code }}",
                            delay: avgDelay
                        })
                    }
                )
            }

            handshakes[i] = performance.now() + (await handshakeTiming.json()).delay;
        }

        handshakes.sort()
        console.log(avgDelay);
        console.log(handshakes[2] - performance.now());
        return handshakes[2] - performance.now() - avgDelay;
    }

    async function do_sync() {
        handshakedTime = await timingHandshake();
        console.log(handshakedTime);
        time_to_show = handshakedTime - {{ memorization_time * 1000 }};
        // redirect to comparison phase after customized seconds
        setTimeout(function() {
            document.getElementById("shapes-frame").style.display = "block";
        }, time_to_show); 
        // redirect to comparison phase after customized seconds
        setTimeout(function() {
            window.location.href = "{{ url_for('memory_test.memory_test_view') }}";
        }, handshakedTime - 300); 
    }

    do_sync()
</script>
{% endblock %}
